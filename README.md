# Power Generation Cost Optimization

## Overview

This project implements an optimization model for minimizing the cost of power generation across multiple power plants while meeting customer demand. The model addresses the economic dispatch problem with unit commitment, determining which power plants to operate and at what capacity to minimize total generation costs.

## Problem Context

In electrical power systems, operators must decide:
- Which power plants to turn on (unit commitment)
- How much power each plant should generate (economic dispatch)

This is challenging because:
- Each plant has different operating costs per MW
- Plants have minimum and maximum capacity constraints
- Some plants may be more efficient but have limited capacity
- Turning a plant on requires it to produce at least its minimum output

## Visual Representation

![Power Generation Problem](pb_modelisation_simplified.png)

The diagram shows three power plants (Centrales 1-3) supplying electricity to a client, each with different:
- **Cost per MW**: Plant 1 (5€/MW) > Plant 2 (4€/MW) > Plant 3 (3€/MW)
- **Capacity**: Plant 1 (100 MW) < Plant 2 (150 MW) < Plant 3 (200 MW)
- **Minimum output**: Plant 1 (20 MW) < Plant 2 (30 MW) < Plant 3 (40 MW)

## Mathematical Formulation

### Problem Definition

We formulate this as a Mixed Integer Linear Programming (MILP) problem that combines:
- **Continuous variables**: Power generation levels
- **Binary variables**: On/off status of each plant

### Sets and Indices
- $I = \{1, 2, 3\}$ : Set of power plants

### Parameters
- $c_i$ : Cost per MW for plant $i$ (€/MW)
  - $c_1 = 5$ €/MW
  - $c_2 = 4$ €/MW  
  - $c_3 = 3$ €/MW

- $C_i$ : Maximum capacity of plant $i$ (MW)
  - $C_1 = 100$ MW
  - $C_2 = 150$ MW
  - $C_3 = 200$ MW

- $M_i$ : Minimum production level of plant $i$ when operational (MW)
  - $M_1 = 20$ MW
  - $M_2 = 30$ MW
  - $M_3 = 40$ MW

- $D$ : Client demand (MW)

### Decision Variables
- $x_i$ : Power generated by plant $i$ (MW), $x_i \geq 0$, continuous
- $y_i$ : Binary variable indicating if plant $i$ is operational
  - $y_i = 1$ if plant $i$ is on
  - $y_i = 0$ if plant $i$ is off

### Objective Function
Minimize total generation cost:

$$\min Z = \sum_{i \in I} c_i \cdot x_i$$

$$\min Z = 5x_1 + 4x_2 + 3x_3$$

### Constraints

#### 1. Demand Satisfaction Constraint
Total power generated must meet or exceed client demand:

$$\sum_{i \in I} x_i \geq D$$

$$x_1 + x_2 + x_3 \geq D$$

#### 2. Minimum Production Constraints
If a plant is operational, it must produce at least its minimum output:

$$x_i \geq M_i \cdot y_i, \quad \forall i \in I$$

Specifically:
- $x_1 \geq 20y_1$
- $x_2 \geq 30y_2$
- $x_3 \geq 40y_3$

#### 3. Maximum Capacity Constraints
Power generated cannot exceed capacity, and can only be positive if plant is on:

$$x_i \leq C_i \cdot y_i, \quad \forall i \in I$$

Specifically:
- $x_1 \leq 100y_1$
- $x_2 \leq 150y_2$
- $x_3 \leq 200y_3$

#### 4. Variable Domain Constraints
- $x_i \geq 0, \quad \forall i \in I$ (non-negativity)
- $y_i \in \{0, 1\}, \quad \forall i \in I$ (binary)

### Complete Formulation

$$\begin{align}
\min \quad & Z = 5x_1 + 4x_2 + 3x_3 \\
\text{s.t.} \quad & x_1 + x_2 + x_3 \geq D \\
& x_1 \geq 20y_1 \\
& x_2 \geq 30y_2 \\
& x_3 \geq 40y_3 \\
& x_1 \leq 100y_1 \\
& x_2 \leq 150y_2 \\
& x_3 \leq 200y_3 \\
& x_i \geq 0, \quad i = 1, 2, 3 \\
& y_i \in \{0, 1\}, \quad i = 1, 2, 3
\end{align}$$

## Solution Properties and Insights

### Coupling Constraints
The constraints $M_i \cdot y_i \leq x_i \leq C_i \cdot y_i$ create a coupling between the continuous variables $x_i$ and binary variables $y_i$:
- If $y_i = 0$, then $x_i = 0$ (plant is off)
- If $y_i = 1$, then $M_i \leq x_i \leq C_i$ (plant operates within bounds)

### Economic Dispatch Logic
The model automatically implements economic dispatch:
- Plant 3 (cheapest) will be preferred when possible
- Plant 2 will be used when Plant 3 alone is insufficient
- Plant 1 (most expensive) will only be used when necessary

### Feasibility Conditions
The problem is feasible if and only if:
$$D \leq \sum_{i \in I} C_i = 100 + 150 + 200 = 450 \text{ MW}$$

### Optimal Solution Structure
For different demand levels:
- If $D \leq 200$ MW: Only Plant 3 operates (if $D \geq 40$ MW)
- If $200 < D \leq 350$ MW: Plants 2 and 3 operate
- If $D > 350$ MW: All plants may need to operate

## Data Components

### Demand Forecasting Data

The project includes historical demand data (`data/dataset_forecasting.csv`) with features:
- **datetime**: Timestamp of the measurement
- **temperature**: Ambient temperature (°C) - affects heating/cooling demand
- **lumiere**: Light intensity - correlates with solar generation and lighting needs
- **pluviometrie**: Rainfall (mm) - impacts renewable generation
- **demande_chaleur**: Heat demand (MW) - the target variable for forecasting

This data can be used to:
1. Forecast future power demand based on weather conditions
2. Plan unit commitment schedules in advance
3. Optimize generation dispatch considering demand uncertainty

## Generalized Formulation

For a system with $n$ plants:

$$\begin{align}
\min \quad & Z = \sum_{i=1}^{n} c_i x_i \\
\text{s.t.} \quad & \sum_{i=1}^{n} x_i \geq D \\
& M_i y_i \leq x_i \leq C_i y_i, \quad \forall i \in \{1, ..., n\} \\
& x_i \geq 0, \quad \forall i \in \{1, ..., n\} \\
& y_i \in \{0, 1\}, \quad \forall i \in \{1, ..., n\}
\end{align}$$

## Practical Applications

This optimization model is used in:
1. **Real-time dispatch**: Determining optimal generation levels every 5-15 minutes
2. **Day-ahead planning**: Scheduling which units to commit for the next day
3. **Economic analysis**: Evaluating the cost impact of different demand scenarios
4. **Capacity planning**: Assessing the need for new generation capacity

## Quick Start with Docker

The easiest way to get started is using Docker:

```bash
# 1. Clone or navigate to the project directory
cd power_geneneration

# 2. Build and start the application
./docker/run.sh build
./docker/run.sh start

# 3. Access Jupyter Lab
# Open http://localhost:8888 in your browser
# Token: power_generation_token

# 4. Test the setup
./docker/test_setup.sh
```

For detailed Docker usage, see [docker/README.md](docker/README.md).

## Implementation Architecture

This project is organized into three main modules:

### 1. Feature Builder (`src/feature_builder/`)
Handles feature engineering for demand forecasting:
- Temporal features (hour, day, seasonality patterns)
- Weather transformations (temperature, light, rainfall)
- Lag features and rolling statistics
- Interaction features between weather and time

### 2. Forecaster (`src/forecaster/`)
Implements demand forecasting using PyTorch Forecasting's Temporal Fusion Transformer:
- Quantile regression for probabilistic predictions (10th, 50th, 90th percentiles)
- 24-hour ahead forecasting with confidence intervals
- Attention mechanisms for interpretability
- Handles both known future inputs (weather) and unknown features

### 3. Optimizer (`src/optimizer/`)
Power generation optimization (to be implemented):
- **Deterministic optimization**: Basic MILP with fixed demand
- **Robust optimization**: Handles demand uncertainty
- **Stochastic optimization**: Multiple scenario optimization with expected value
- Integrates seamlessly with forecaster's confidence intervals

## Docker Environment

The framework includes a comprehensive Docker setup:

### Available Services
- **Main App**: Jupyter Lab environment for interactive development
- **Development**: Container for development work
- **Training**: Dedicated environment for model training
- **Database**: PostgreSQL for data storage (optional)
- **Cache**: Redis for caching (optional)
- **Monitoring**: Grafana dashboards (optional)

### Quick Commands
```bash
# Start main application
./docker/run.sh start

# Development environment
./docker/run.sh dev

# Training environment  
./docker/run.sh train

# Full stack with database
./docker/run.sh full

# Stop all services
./docker/run.sh stop

# View logs
./docker/run.sh logs

# Execute commands in container
./docker/run.sh exec python example_usage.py
```

## Usage Example

```python
from src.feature_builder import FeatureBuilder
from src.forecaster import DemandForecaster

# 1. Feature Engineering
fb = FeatureBuilder()
features_df = fb.fit_transform(raw_data)

# 2. Demand Forecasting
forecaster = DemandForecaster()
train_loader, val_loader = forecaster.prepare_data(features_df)
forecaster.train(train_loader, val_loader)
next_day_forecast = forecaster.predict_next_day(current_data)

# 3. Power Optimization (example implementation)
plants = {
    1: {'name': 'Plant 1', 'cost': 5, 'min_capacity': 20, 'max_capacity': 100},
    2: {'name': 'Plant 2', 'cost': 4, 'min_capacity': 30, 'max_capacity': 150},
    3: {'name': 'Plant 3', 'cost': 3, 'min_capacity': 40, 'max_capacity': 200}
}

# Simple optimization logic
for hour_demand in next_day_forecast:
    optimal_dispatch = optimize_generation(hour_demand, plants)
    print(f"Hour demand: {hour_demand}, Dispatch: {optimal_dispatch}")
```

## Requirements

Core dependencies (automatically installed in Docker):
- Python 3.9+
- PyTorch & PyTorch Lightning
- pytorch-forecasting
- pandas, numpy, scikit-learn
- PuLP, CVXPy (for optimization)
- Jupyter Lab for interactive development